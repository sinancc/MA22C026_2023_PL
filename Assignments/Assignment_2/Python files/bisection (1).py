# -*- coding: utf-8 -*-
"""Bisection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uwRC7QCzlpv6CVABLm3zWnQA7J6cEpkL
"""

import math

def bisection(func,a,b,epsilon,niters):
  if (func(a) * func(b) > 0): #we have to get f(a)*f(b)<0 inorder to do bisection
    print("PUT ANOTHER GUESSES FOR A & B \n")
  elif (func(a) * func(b) == 0): #either one of them has to be zero,means one is a solution
    if func(a)==0:
      Print(a,"is the root")
    else:
      print(b, "is the root")
  count=0
  c = a #inorder to define conditions
  while (abs(func(c)) >= epsilon) and count<=niters and (func(a) * func(b) < 0): #introducing conditions required for bisection
   # Find middle point
      c = (a+b)/2

      # Check whether middle point is root
      if (func(c) == 0.0):
          break

      # Decide the side to repeat the steps
      if (func(c)*func(a) < 0):
        b = c
      else:
        a = c
      count+=1
  print("The value of root is : ","%.11f"%c) #root
  print(count) #total number of iterations
  print(func(c)) #error

def func(x):
  return x-1-math.cos(x)
#we have to change this code for changing function

a=float(input("Enter lower guess"))
b=float(input("Enter upper guess"))
epsilon=float(input("Enter your error bound"))
niters=int(input("Enter max no of iterations"))
bisection(func,a,b,epsilon,niters)
#input your upper lower limits,error bound,max no of iters etc here

bisection(func,a=1,b=2,epsilon=1E-6,niters=100)
#just a test case

